#!/usr/bin/env python3
"""
Hadwiger's Conjecture Validation Test Runner

This module runs the qi_validate C++ program on all graphs in the graphs directory
and collects results into a summary report.
"""

import os
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List, Tuple
import glob


class ValidationResult:
    """Represents the result of validating a single graph."""
    
    def __init__(self, graph_file: str):
        self.graph_file = graph_file
        self.graph_name = Path(graph_file).stem
        self.vertices = 0
        self.critical_k = 0
        self.steps = 0
        self.result = "UNKNOWN"
        self.detail = ""
        self.success = False
        self.error_message = ""
    
    def __str__(self):
        return f"{self.graph_name}: {self.result} ({self.vertices}v, k'={self.critical_k}, {self.steps} steps)"


class TestRunner:
    """Runs validation tests on all graphs and collects results."""
    
    def __init__(self, qi_validate_exe: str = "./out/build/x64-Release/qi_validate.exe"):
        self.qi_validate_exe = qi_validate_exe
        self.results: List[ValidationResult] = []
    
    def find_all_graphs(self, graphs_dir: str = "graphs") -> List[str]:
        """Find all .txt graph files in the graphs directory."""
        graph_files = []
        
        # Search all subdirectories for .txt files
        for root, dirs, files in os.walk(graphs_dir):
            for file in files:
                if file.endswith('.txt') and not file.startswith('README'):
                    graph_files.append(os.path.join(root, file))
        
        # Sort for consistent ordering
        graph_files.sort()
        return graph_files
    
    def run_validation(self, graph_file: str) -> ValidationResult:
        """Run validation on a single graph file."""
        result = ValidationResult(graph_file)
        
        try:
            # Check graph size before running validation
            vertex_count = self._get_vertex_count(graph_file)
            if vertex_count > 30:
                result.result = "SKIPPED"
                result.vertices = vertex_count
                result.error_message = f"Graph too large ({vertex_count} vertices > 30 limit)"
                return result
            # Create temporary file for output
            with tempfile.NamedTemporaryFile(mode='w+', suffix='.txt', delete=False) as temp_file:
                temp_output = temp_file.name
            
            # Run qi_validate with output redirection
            cmd = [self.qi_validate_exe, graph_file, "--output", temp_output]
            
            # Run with timeout to prevent hanging
            proc = subprocess.run(
                cmd, 
                capture_output=True, 
                text=True, 
                timeout=60  # 60 second timeout
            )
            
            # Parse output file if it exists
            if os.path.exists(temp_output):
                self._parse_output_file(temp_output, result)
                os.unlink(temp_output)  # Clean up temp file
            
            result.success = (proc.returncode == 0)
            
            # If process failed, capture error
            if proc.returncode != 0 and result.result == "UNKNOWN":
                if proc.stderr:
                    result.error_message = proc.stderr.strip()
                else:
                    result.error_message = f"Process exited with code {proc.returncode}"
                result.result = "ERROR"
            
        except subprocess.TimeoutExpired:
            result.result = "TIMEOUT"
            result.error_message = "Validation timed out after 60 seconds"
            result.success = False
        except Exception as e:
            result.result = "ERROR"
            result.error_message = str(e)
            result.success = False
        
        return result
    
    def _parse_output_file(self, output_file: str, result: ValidationResult):
        """Parse the output file generated by qi_validate."""
        try:
            with open(output_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith("VERTICES: "):
                        result.vertices = int(line.split(": ")[1])
                    elif line.startswith("CRITICAL_K: "):
                        result.critical_k = int(line.split(": ")[1])
                    elif line.startswith("STEPS: "):
                        result.steps = int(line.split(": ")[1])
                    elif line.startswith("RESULT: "):
                        result.result = line.split(": ")[1]
                    elif line.startswith("DETAIL: "):
                        result.detail = line.split(": ", 1)[1]
        except Exception as e:
            result.error_message = f"Failed to parse output: {e}"
    
    def _get_vertex_count(self, graph_file: str) -> int:
        """Get the number of vertices from a graph file."""
        try:
            with open(graph_file, 'r') as f:
                first_line = f.readline().strip()
                return int(first_line)
        except Exception:
            return 0  # Default to 0 if can't read
    
    def run_all_tests(self, graphs_dir: str = "graphs") -> List[ValidationResult]:
        """Run validation on all graphs and return results."""
        graph_files = self.find_all_graphs(graphs_dir)
        
        print(f"Found {len(graph_files)} graph files to validate...")
        print(f"Using validator: {self.qi_validate_exe}")
        print()
        
        for i, graph_file in enumerate(graph_files, 1):
            print(f"[{i:3d}/{len(graph_files):3d}] Testing {graph_file}...")
            
            result = self.run_validation(graph_file)
            self.results.append(result)
            
            # Print immediate result
            if result.result == "PASS":
                print(f"         PASS ({result.vertices}v, k'={result.critical_k}, {result.steps} steps)")
            elif result.result == "PARTIAL":
                print(f"         PARTIAL ({result.vertices}v, k'={result.critical_k}, {result.steps} steps)")
            elif result.result == "FAIL":
                print(f"         FAIL ({result.vertices}v, k'={result.critical_k}, {result.steps} steps)")
            elif result.result == "TIMEOUT":
                print(f"         TIMEOUT ({result.vertices}v, k'={result.critical_k})")
            elif result.result == "SKIPPED":
                print(f"         SKIPPED ({result.vertices}v - too large)")
            else:
                print(f"         ERROR: {result.error_message}")
        
        return self.results
    
    def generate_summary_report(self, output_file: str = "validation_summary.txt"):
        """Generate a summary report of all validation results."""
        
        # Count results by type
        counts = {
            "PASS": 0,
            "PARTIAL": 0, 
            "FAIL": 0,
            "TIMEOUT": 0,
            "SKIPPED": 0,
            "ERROR": 0
        }
        
        for result in self.results:
            counts[result.result] = counts.get(result.result, 0) + 1
        
        total = len(self.results)
        
        # Generate report
        with open(output_file, 'w') as f:
            f.write("Hadwiger's Conjecture Validation Summary Report\n")
            f.write("=" * 50 + "\n\n")
            
            f.write(f"Total graphs tested: {total}\n")
            f.write(f"PASS:     {counts['PASS']:3d} ({counts['PASS']/total*100:5.1f}%)\n")
            f.write(f"PARTIAL:  {counts['PARTIAL']:3d} ({counts['PARTIAL']/total*100:5.1f}%)\n")
            f.write(f"FAIL:     {counts['FAIL']:3d} ({counts['FAIL']/total*100:5.1f}%)\n")
            f.write(f"TIMEOUT:  {counts['TIMEOUT']:3d} ({counts['TIMEOUT']/total*100:5.1f}%)\n")
            f.write(f"SKIPPED:  {counts['SKIPPED']:3d} ({counts['SKIPPED']/total*100:5.1f}%)\n")
            f.write(f"ERROR:    {counts['ERROR']:3d} ({counts['ERROR']/total*100:5.1f}%)\n\n")
            
            # Detailed results by category
            for status in ["PASS", "PARTIAL", "FAIL", "TIMEOUT", "SKIPPED", "ERROR"]:
                category_results = [r for r in self.results if r.result == status]
                if category_results:
                    f.write(f"\n{status} Results ({len(category_results)}):\n")
                    f.write("-" * 30 + "\n")
                    for result in category_results:
                        f.write(f"{result.graph_name:<25} {result.vertices:2d}v k'={result.critical_k} ")
                        if result.steps > 0:
                            f.write(f"({result.steps:2d} steps)")
                        if result.detail:
                            f.write(f" - {result.detail}")
                        if result.error_message:
                            f.write(f" - {result.error_message}")
                        f.write("\n")
        
        print(f"\nSummary report written to: {output_file}")
        return output_file


def main():
    """Main function for running the test suite."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Run qi validation on all graphs")
    parser.add_argument("--graphs-dir", default="graphs", 
                       help="Directory containing graph files (default: graphs)")
    parser.add_argument("--validator", default="./out/build/x64-Release/qi_validate.exe",
                       help="Path to qi_validate executable")
    parser.add_argument("--output", default="validation_summary.txt",
                       help="Output summary file (default: validation_summary.txt)")
    
    args = parser.parse_args()
    
    # Check if validator exists
    if not os.path.exists(args.validator):
        print(f"Error: Validator executable not found: {args.validator}")
        print("Please build the project first with CMake")
        return 1
    
    # Run tests
    runner = TestRunner(args.validator)
    results = runner.run_all_tests(args.graphs_dir)
    
    # Generate summary
    runner.generate_summary_report(args.output)
    
    # Print final summary to console
    total = len(results)
    passed = len([r for r in results if r.result == "PASS"])
    partial = len([r for r in results if r.result == "PARTIAL"])
    failed = len([r for r in results if r.result == "FAIL"])
    skipped = len([r for r in results if r.result == "SKIPPED"])
    
    print(f"\nFinal Summary:")
    print(f"  Total: {total}, Pass: {passed}, Partial: {partial}, Fail: {failed}, Skipped: {skipped}")
    
    return 0 if failed == 0 else 1


if __name__ == "__main__":
    exit(main())